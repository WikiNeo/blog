---
title: 'Binary Trees Terminology'
tags: [Tree]
date: 2026-02-11
---

## ğŸŒ³ Binary Tree Terminology (Clear & Structured Guide)

A **binary tree** is a hierarchical data structure where each node has **at most two children** â€” usually called **left child** and **right child**.

Since youâ€™re comfortable with data structures (given your Git and system-level questions before), Iâ€™ll keep this technically precise but clean.

---

## 1ï¸âƒ£ Basic Components

### ğŸ”¹ Node

A fundamental unit of a tree containing:

* A value (data)
* A left child pointer/reference
* A right child pointer/reference

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

---

### ğŸ”¹ Root

The **topmost node** of the tree.

Example:

```
      10
     /  \
    5    20
```

Here, `10` is the **root**.

---

### ğŸ”¹ Parent and Child

If node A connects to node B downward:

* A = **parent**
* B = **child**

In the above example:

* 10 is parent of 5 and 20
* 5 and 20 are children of 10

---

### ğŸ”¹ Siblings

Nodes that share the same parent.

* 5 and 20 are siblings.

---

### ğŸ”¹ Leaf Node

A node with **no children**.

In this tree:

```
      10
     /  \
    5    20
```

Nodes `5` and `20` are **leaf nodes**.

---

### ğŸ”¹ Internal Node

Any node that is **not a leaf**.

Here:

* 10 is an internal node.

---

## 2ï¸âƒ£ Structural Terminology

### ğŸ”¹ Subtree

A node together with all its descendants.

Example:
The subtree rooted at 5:

```
    5
```

If it had children, they would be included.

---

### ğŸ”¹ Depth

Number of edges from root to a node.

Example:

```
      10        (depth 0)
     /  \
    5    20     (depth 1)
         /
        15      (depth 2)
```

* Depth(10) = 0
* Depth(15) = 2

---

### ğŸ”¹ Height

Number of edges in the longest path from a node to a leaf.

* Height of a leaf = 0
* Height of the tree = height of root

For the above tree:

* Height(15) = 0
* Height(20) = 1
* Height(10) = 2

---

### ğŸ”¹ Level

Sometimes used interchangeably with depth, but often:

```
level = depth + 1
```

Root is level 1.

---

## 3ï¸âƒ£ Types of Binary Trees

---

### ğŸ”¹ Full Binary Tree

Every node has **either 0 or 2 children**.

```
      10
     /  \
    5    20
   / \
  3   7
```

---

### ğŸ”¹ Complete Binary Tree

All levels are filled except possibly the last,
and nodes are filled **left to right**.

Example:

```
      1
     / \
    2   3
   / \  /
  4  5 6
```

Used in:

* Heaps
* Priority queues

---

### ğŸ”¹ Perfect Binary Tree

All internal nodes have 2 children,
and all leaves are at the same level.

Height = h
Nodes = 2^(h+1) - 1

---

### ğŸ”¹ Balanced Binary Tree

Height difference between left and right subtree is small
(often â‰¤ 1 for every node).

Example:

* AVL tree
* Red-Black tree

---

### ğŸ”¹ Skewed Tree

All nodes lean to one side.

Left-skewed:

```
    10
    /
   5
  /
 3
```

Worst-case height = n
Behaves like a linked list.

---

## 4ï¸âƒ£ Special Binary Trees

### ğŸ”¹ Binary Search Tree (BST)

For every node:

```
left subtree < node < right subtree
```

Example:

```
      10
     /  \
    5    20
         /
        15
```

Why important?

* Average search: O(log n)
* Worst case: O(n) if skewed

---

### ğŸ”¹ Heap (Binary Heap)

Complete binary tree where:

* Min-heap: parent â‰¤ children
* Max-heap: parent â‰¥ children

---

## 5ï¸âƒ£ Traversal Terminology

Traversal = visiting all nodes in some order.

### ğŸ”¹ DFS Traversals

**Inorder (LNR)**
Left â†’ Node â†’ Right
(BST gives sorted order)

**Preorder (NLR)**
Node â†’ Left â†’ Right
(used for tree copy)

**Postorder (LRN)**
Left â†’ Right â†’ Node
(used for deletion)

Example:

```
      10
     /  \
    5    20
```

* Inorder: 5, 10, 20
* Preorder: 10, 5, 20
* Postorder: 5, 20, 10

---

### ğŸ”¹ BFS (Level Order)

Visit level by level:

10 â†’ 5 â†’ 20

Uses a queue.

```python
from collections import deque

def level_order(root):
    if not root:
        return
    
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        print(node.value)
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
```

---

## 6ï¸âƒ£ Important Mathematical Properties

For a binary tree:

* Maximum nodes at level `d` = 2^d
* Maximum nodes in height `h` tree = 2^(h+1) - 1
* Minimum height for n nodes â‰ˆ logâ‚‚(n)

---

## 7ï¸âƒ£ Edge Cases to Know (Interview Favorites)

* Empty tree (root = None)
* Single-node tree
* Completely skewed tree
* Balanced vs unbalanced height
* Null children handling

---

# ğŸ¯ Summary Mental Model

Think of binary tree as:

```
Recursive structure
node
 â”œâ”€â”€ left subtree
 â””â”€â”€ right subtree
```

Everything â€” height, traversal, search â€” is recursive by nature.

---
