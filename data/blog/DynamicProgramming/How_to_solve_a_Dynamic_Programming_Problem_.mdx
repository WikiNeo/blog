---
title: "How to solve a Dynamic Programming Problem ?"
tags: [DynamicProgramming]
date: 2025-12-26
---

Dynamic Programming (DP) is about **breaking a complex problem into smaller overlapping subproblems and reusing their results** instead of recomputing them.

Below is a **clear, repeatable framework** you can apply to *almost any DP problem*, plus a Python example.

---

## 1Ô∏è‚É£ Recognize a DP Problem

A problem is suitable for DP if it has **both**:

### ‚úÖ Overlapping Subproblems

* Same subproblems appear multiple times
* Example: Fibonacci, knapsack, shortest paths

### ‚úÖ Optimal Substructure

* Optimal solution can be built from optimal solutions of subproblems
* Example: shortest path to node `X` uses shortest paths to previous nodes

> If brute force recursion repeats work ‚Üí DP is likely the answer.

---

## 2Ô∏è‚É£ Define the State (The Most Important Step)

Ask yourself:

> **What is the minimum information needed to describe a subproblem?**

Examples:

* `dp[i]` ‚Üí answer for first `i` elements
* `dp[i][j]` ‚Üí answer using first `i` items with capacity `j`
* `dp[i][j]` ‚Üí best answer for substring `s[i:j]`

**Rule of thumb**:

> One DP dimension = one decision axis

---

## 3Ô∏è‚É£ Write the Recurrence Relation

Express how the state depends on **smaller states**.

General form:

```text
dp[state] = best(
    dp[smaller_state_1],
    dp[smaller_state_2],
    ...
)
```

Examples:

* Fibonacci:

```text
dp[n] = dp[n-1] + dp[n-2]
```

* Coin change:

```text
dp[x] = min(dp[x - coin] + 1)
```

---

## 4Ô∏è‚É£ Identify Base Cases

Base cases **stop the recursion** and anchor the DP.

Examples:

```text
dp[0] = 0
dp[1] = 1
dp[empty_string] = true
```

If your base cases are wrong ‚Üí the entire solution fails.

---

## 5Ô∏è‚É£ Choose DP Style

### üü¶ Top-Down (Memoization)

* Recursive + cache
* Easier to write
* Good for complex states

```python
from functools import lru_cache

@lru_cache(None)
def dp(n):
    if n <= 1:
        return n
    return dp(n - 1) + dp(n - 2)
```

### üü© Bottom-Up (Tabulation)

* Iterative
* Faster, no recursion
* Easier to optimize space

```python
dp = [0, 1]
for i in range(2, n + 1):
    dp.append(dp[i - 1] + dp[i - 2])
```

---

## 6Ô∏è‚É£ Decide the Iteration Order

You **must compute smaller states first**.

Examples:

* 1D DP ‚Üí left to right
* 2D DP on strings ‚Üí increasing length
* Knapsack ‚Üí careful about loop direction

> Wrong iteration order = wrong answer ‚ùå

---

## 7Ô∏è‚É£ Optimize Space (If Needed)

Many DP problems only need **previous states**.

Example: Fibonacci

```python
a, b = 0, 1
for _ in range(n):
    a, b = b, a + b
```

Space drops from `O(n)` ‚Üí `O(1)`.

---

## 8Ô∏è‚É£ Worked Example: Climbing Stairs

### Problem

You can climb `n` stairs, taking 1 or 2 steps at a time.
How many distinct ways?

### Step-by-step

#### State

```text
dp[i] = number of ways to reach step i
```

#### Recurrence

```text
dp[i] = dp[i-1] + dp[i-2]
```

#### Base cases

```text
dp[0] = 1
dp[1] = 1
```

#### Python solution

```python
def climb_stairs(n: int) -> int:
    if n <= 1:
        return 1

    dp = [0] * (n + 1)
    dp[0] = dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
```

---

## 9Ô∏è‚É£ Common DP Patterns (Learn These!)

| Pattern         | Examples                    |
| --------------- | --------------------------- |
| **1D DP**       | Fibonacci, Climbing Stairs  |
| **Knapsack**    | 0/1 Knapsack, Coin Change   |
| **String DP**   | LCS, Edit Distance          |
| **Grid DP**     | Unique Paths, Min Path Sum  |
| **Interval DP** | Matrix Chain Multiplication |
| **Bitmask DP**  | TSP, subsets                |

---

## 10Ô∏è‚É£ Mental Checklist (Use This Every Time)

‚úî What is my **state**?
‚úî What is the **transition**?
‚úî What are the **base cases**?
‚úî What is the **order of computation**?
‚úî Can I **optimize space**?

