---
title: "[Behavioral Design Pattern] Template"
tags: [DesignPattern]
date: 2022-04-23
summary: The **Template Method** design pattern is a **behavioral pattern** that defines the skeleton of an algorithm in a base class and lets subclasses override specific steps of the algorithm without changing its structure.
---

The **Template Method** design pattern is a **behavioral pattern** that defines the skeleton of an algorithm in a base class and lets subclasses override specific steps of the algorithm without changing its structure.

---

### ðŸ“Œ Intent

Define the **outline of an algorithm** in a method, deferring some steps to subclasses.

---

### ðŸ”§ Use Case

Use Template Method when:

- You want to avoid code duplication in subclasses that follow the same overall process.
- You want to let subclasses refine parts of an algorithm without changing its structure.

---

### ðŸ§± Structure

```
BaseClass (abstract)
â”œâ”€â”€ template_method()  # defines algorithm skeleton
â”œâ”€â”€ step1()            # concrete method
â”œâ”€â”€ step2()            # abstract / hook method
â””â”€â”€ step3()            # concrete or hook method

ConcreteSubclass (inherits BaseClass)
â”œâ”€â”€ override step2()
```

---

### ðŸ Python Example

```python
from abc import ABC, abstractmethod

class DataProcessor(ABC):
    def process(self):
        self.read_data()
        self.transform_data()
        self.save_data()

    def read_data(self):
        print("Reading data from source")

    @abstractmethod
    def transform_data(self):
        pass

    def save_data(self):
        print("Saving data to destination")

class CSVProcessor(DataProcessor):
    def transform_data(self):
        print("Transforming CSV data")

class JSONProcessor(DataProcessor):
    def transform_data(self):
        print("Transforming JSON data")

# Client code
csv = CSVProcessor()
csv.process()
# Output:
# Reading data from source
# Transforming CSV data
# Saving data to destination
```

---

### âœ… Benefits

- Promotes **code reuse** and **consistency**.
- Simplifies maintenance by centralizing the algorithm structure.

---

### âš ï¸ Drawbacks

- Can lead to **inflexible inheritance** hierarchies.
- Not ideal if steps vary significantly across subclasses.

---

### ðŸ§  Related Patterns

- **Strategy**: Encapsulates each algorithm variant in a separate class. More flexible than inheritance.

## Real world example

Suppose we are getting some house built. The steps for building might look
like

- Prepare the base of house
- Build the walls
- Add roof
- Add other floors

The order of these steps could never be changed i.e. you can't build the roof
before building the walls etc but each of the steps could be modified for
example walls can be made of wood or polyester or stone.

## In plain words

Template method defines the skeleton of how a certain algorithm could be
performed, but defers the implementation of those steps to the children
classes.

## Wikipedia says

In software engineering, the template method pattern is a behavioral design
pattern that defines the program skeleton of an algorithm in an operation,
deferring some steps to subclasses. It lets one redefine certain steps of an
algorithm without changing the algorithm's structure.

## Programmatic Example

Imagine we have a build tool that helps us test, lint, build, generate build
reports (i.e. code coverage reports, linting report etc) and deploy our app on
the test server.

First of all we have our base class that specifies the skeleton for the build
algorithm

```typescript
abstract class Builder {
  // template method
  build() {
    this.test();
    this.lint();
    this.assemble();
    this.deploy();
  }

  abstract test();
  abstract lint();
  abstract assemble();
  abstract deploy();
}
```

Then we can have our implementations

```typescript
class AndroidBuilder extends Builder {
  test() {
    console.log("android test");
  }

  lint() {
    console.log("android lint");
  }

  assemble() {
    console.log("android assemble");
  }

  deploy() {
    console.log("android deploy");
  }
}

class IosBuilder extends Builder {
  test() {
    console.log("ios test");
  }

  lint() {
    console.log("ios lint");
  }

  assemble() {
    console.log("ios assemble");
  }

  deploy() {
    console.log("ios deploy");
  }
}
```

And then it can be used as

```typescript
test("test template pattern", () => {
  const androidBuilder = new AndroidBuilder();
  androidBuilder.build();

  const iosBuilder = new IosBuilder();
  iosBuilder.build();
});
```

## References

- [https://github.com/kamranahmedse/design-patterns-for-humans](https://github.com/kamranahmedse/design-patterns-for-humans)
- [https://github.com/torokmark/design_patterns_in_typescript](https://github.com/torokmark/design_patterns_in_typescript)
- [https://refactoring.guru/design-patterns](https://refactoring.guru/design-patterns)

